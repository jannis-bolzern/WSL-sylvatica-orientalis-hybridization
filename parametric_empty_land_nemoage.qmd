---
title: "Parametric empty-land simulations (Nemo-age inputs)"
author: "Jannis Bolzern"
format:
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    code-fold: true
    code-summary: "Show code"
editor: visual
execute:
  echo: true
  warning: false
  message: false
  freeze: false
---

## Overview

This document generates *empty-land* spatial configurations for **Nemo-age** hybridization simulations using a **parameter-driven** design.

Instead of using questionnaire-drawn planting schemes, we define scenarios by:

-   **Orientalis proportion** (e.g. 5%, 20%, 50%)
-   **Spatial pattern** (3 levels):
    -   **dispersed**: regular-ish spacing (min-distance sampling on a discrete grid)
    -   **small_clusters**: several clusters with **soft edges** (no scattered singletons)
    -   **big_clusters**: two **hard-edge** clusters (balanced sizes)

For each scenario we generate **replicates** (stochastic alternative layouts), write Nemo-age input files, and create overview plots.

### Outputs written

For each simulation `sim_name`, the pipeline writes:

-   `configs_txt/<sim_name>.txt`\
    Columns: `simulation`, `patchID`, `patch_value` (`S` or `O`)
-   `quanti_init_freq/quanti_init_file_<sim_name>.txt`\
    Nemo matrix (625×1): 0 = *sylvatica*, 1 = *orientalis*
-   `patch_init_stage_size/patch_init_stage_size_<sim_name>.txt`\
    Nemo matrix (625×4): stage planting counts per patch
-   `plots/replicates/overview_<scenario>.png`\
    A combined plot showing **all replicates** side-by-side

------------------------------------------------------------------------

## Libraries

```{r}
#| label: libraries
suppressPackageStartupMessages({
  library(terra)
  library(data.table)
  library(ggplot2)
  library(cowplot)
  library(dplyr)
})
```

------------------------------------------------------------------------

## Global settings

These settings define the landscape, scenario design, file paths, and planting scheme.

```{r}
#| label: global-settings

# Output folder
OUT_BASE <- "input_files"
DIRS <- list(
  grid   = file.path(OUT_BASE, "grid"),
  cfg    = file.path(OUT_BASE, "configs_txt"),
  quanti = file.path(OUT_BASE, "quanti_init_freq"),
  stage  = file.path(OUT_BASE, "patch_init_stage_size"),
  plots  = file.path(OUT_BASE, "plots")
)
dir.create(OUT_BASE, showWarnings = FALSE, recursive = TRUE)
for (d in DIRS) dir.create(d, showWarnings = FALSE, recursive = TRUE)

# Landscape grid: 100×100 m with 4×4 m patches => 25×25 = 625 patches
GRID_RES <- 4
EXTENT_M <- 100
N <- EXTENT_M / GRID_RES
CRS <- "EPSG:3035"
GRID_SHP <- file.path(DIRS$grid, "Grid_4x4m_100x100m.shp")

# Scenario design: 3 proportions × 3 spatial patterns × N replicates
PROP_LEVELS <- c(0.05, 0.20, 0.50)
CLUSTER_LEVELS <- c("dispersed", "small_clusters", "big_clusters")
N_REPS <- 5

# Empty land planting scheme (stage0, stage1, stage2, stage3)
# Here: ~20 seedlings (stage1) in every patch; species identity is set via quanti_init_freq.
PLANTING_SCHEME <- c(0, 20, 0, 0)

# Seed base for reproducibility across scenarios
SEED_BASE <- 20260116
```

------------------------------------------------------------------------

## Cluster control panel

This is the main tuning interface. **Custer size**, **cluster count**, **edge softness/hardness**, and **regularity** can be adjsuted without changing any generator code.

### Quick interpretation of parameters

#### Dispersed

-   `strength` controls how “evenly interspaced” the O patches are.
    -   higher → more regular spacing
    -   lower → more random, more chance of clumping
-   `relax_step` / `max_relax` provide a fallback if min-distance is too strict for the requested O count.

#### Small clusters

-   `n_centers` = number of cluster centers (more centers → more clusters, usually smaller)
-   `sigma_m` = cluster compactness
    -   lower → tighter/more clustered
    -   higher → fuzzier/larger clusters
-   `bleed_rate` = fraction of O patches added just outside clusters (softens boundary)
-   `bleed_dist` = maximum distance (meters) from current O patches where “bleed” is allowed

#### Big clusters

-   `n_centers` = number of cluster centers (more centers → more clusters, usually smaller)
-   `jitter` controls imbalance between the cluster sizes
    -   0 → perfect 50/50 split
    -   higher → more unequal cluster sizes

```{r}
#| label: cluster-control-panel

CLUSTER_OPTS <- list(
  dispersed = list(
    strength = 1.20,
    relax_step = 0.95,
    max_relax = 12
  ),
  small_clusters = list(
    n_centers  = 8,
    sigma_m    = 3.2,
    bleed_rate = 0.08,
    bleed_dist = 10
  ),
  big_clusters = list(
    n_centers = 2,
    jitter = 0.10
  )
)
```

------------------------------------------------------------------------

## Build or load the grid

We create a strict 25×25 grid (4×4 m patches) and enforce a **row-wise** patchID ordering (1…625).

```{r}
#| label: grid

make_or_load_grid_strict <- function(shp_path, extent_m = 100, res = 4, crs = "EPSG:3035") {
  if (file.exists(shp_path)) return(vect(shp_path))

  r <- rast(extent = ext(0, extent_m, 0, extent_m), resolution = res, crs = crs)
  r[] <- 1:ncell(r)  # cell index defines patchID in row-wise raster order

  grid_poly <- as.polygons(r, dissolve = FALSE)
  names(grid_poly)[names(grid_poly) == "lyr.1"] <- "patchID"

  writeVector(grid_poly, shp_path, filetype = "ESRI Shapefile", overwrite = TRUE)
  grid_poly
}

grid <- make_or_load_grid_strict(GRID_SHP, EXTENT_M, GRID_RES, CRS)
stopifnot(nrow(grid) == N * N)

cent <- centroids(grid)

coords <- as.data.frame(crds(cent))
names(coords) <- c("x", "y")
coords$patchID <- grid$patchID

# For matrix-like plotting
coords$row <- ((coords$patchID - 1) %/% N) + 1
coords$col <- ((coords$patchID - 1) %%  N) + 1
coords$y_plot <- N - coords$row + 1
coords$x_plot <- coords$col

patch_ids <- coords$patchID
n_patches <- length(patch_ids)

# Distance matrix between patch centroids (meters)
dist_mat <- as.matrix(distance(cent))

list(n_patches = n_patches, min_dist = min(dist_mat[dist_mat > 0]), max_dist = max(dist_mat))
```

------------------------------------------------------------------------

## Nemo helpers

These functions convert generated patch assignments into Nemo-age input files.

```{r}
#| label: nemo-helpers

write.matrix.nemo <- function(mat, outfile) {
  cat("{", file = outfile)
  for (i in seq_len(nrow(mat))) {
    cat("{", file = outfile, append = TRUE)
    cat(mat[i, ], sep = ",", file = outfile, append = TRUE)
    cat("}\n", file = outfile, append = TRUE)
  }
  cat("}\n", file = outfile, append = TRUE)
}

scenario_id <- function(p_orientalis, cluster_level, rep_id) {
  p_lab <- sprintf("p%02d", round(100 * p_orientalis))
  sprintf("empty_%s_%s_rep%02d", p_lab, cluster_level, rep_id)
}

build_patch_init_stage_size_empty <- function(n_patches, scheme = c(0, 20, 0, 0)) {
  mat <- matrix(rep(scheme, each = n_patches), nrow = n_patches, ncol = 4, byrow = FALSE)
  colnames(mat) <- c("stage0", "stage1", "stage2", "stage3")
  mat
}

build_config_table <- function(orientalis_ids, patch_ids) {
  dt <- data.table(patchID = patch_ids, patch_value = "S")
  dt[patchID %in% orientalis_ids, patch_value := "O"]
  dt[order(patchID)]
}

build_quanti_init <- function(conf_dt, n_patches) {
  mat <- matrix(0, nrow = n_patches, ncol = 1)
  mat[conf_dt$patchID, 1] <- ifelse(conf_dt$patch_value == "O", 1, 0)
  mat
}

write_config_quarto_schema <- function(conf_dt, sim_name, outfile) {
  out <- copy(conf_dt)
  out[, simulation := sim_name]
  setcolorder(out, c("simulation", "patchID", "patch_value"))
  fwrite(out, outfile, sep = "\t")
}
```

------------------------------------------------------------------------

## Placement generators

Each generator returns a vector of patchIDs that should be **O** (*orientalis*). All other patches become **S** (*sylvatica*).

### Dispersed generator

```{r}
#| label: generator-dispersed

select_orientalis_dispersed_poisson <- function(
  nO, patch_ids, dist_mat, base_spacing_m, seed = NULL,
  strength = 1.20,
  relax_step = 0.95,
  max_relax = 12
) {
  if (!is.null(seed)) set.seed(seed)
  if (nO <= 0) return(integer(0))
  if (nO >= length(patch_ids)) return(patch_ids)

  minDist <- base_spacing_m * strength
  chosen <- integer(0)

  for (attempt in seq_len(max_relax)) {
    chosen <- integer(0)
    available <- sample(patch_ids)

    for (cand in available) {
      if (length(chosen) == 0) {
        chosen <- c(chosen, cand)
      } else {
        if (min(dist_mat[cand, chosen]) >= minDist) chosen <- c(chosen, cand)
      }
      if (length(chosen) >= nO) break
    }

    if (length(chosen) >= nO) return(chosen[1:nO])
    minDist <- minDist * relax_step
  }

  if (length(chosen) < nO) {
    chosen <- c(chosen, sample(setdiff(patch_ids, chosen), nO - length(chosen)))
  }
  chosen
}
```

### Small clusters generator

```{r}
#| label: generator-small-clusters

select_orientalis_small_clusters_soft <- function(
  nO, patch_ids, dist_mat, seed = NULL,
  n_centers = 8,
  sigma_m = 3.2,
  bleed_rate = 0.08,
  bleed_dist = 10
) {
  if (!is.null(seed)) set.seed(seed)
  if (nO <= 0) return(integer(0))
  if (nO >= length(patch_ids)) return(patch_ids)

  n_centers <- min(n_centers, nO)
  centers <- sample(patch_ids, n_centers)

  # allocate per-center sizes (balanced-ish)
  w <- runif(n_centers); w <- w / sum(w)
  sizes <- pmax(1, as.integer(round(w * nO)))
  sizes[1] <- sizes[1] + (nO - sum(sizes))

  chosen <- integer(0)
  remaining <- patch_ids

  # core clusters (distance-weighted around each center)
  for (k in seq_len(n_centers)) {
    c0 <- centers[k]
    d <- dist_mat[c0, remaining]
    prob <- exp(-(d^2) / (2 * sigma_m^2))
    prob <- prob / sum(prob)

    take <- sample(
      remaining,
      size = min(sizes[k], length(remaining)),
      replace = FALSE,
      prob = prob
    )

    chosen <- c(chosen, take)
    remaining <- setdiff(remaining, take)
    if (length(chosen) >= nO) break
  }

  chosen <- unique(chosen)

  # ensure exactly nO before edge processing
  if (length(chosen) > nO) chosen <- sample(chosen, nO)
  if (length(chosen) < nO) chosen <- c(chosen, sample(setdiff(patch_ids, chosen), nO - length(chosen)))

  # --- BLEED: add O near current O to soften edges
  n_bleed <- as.integer(round(bleed_rate * nO))
  if (n_bleed > 0 && length(chosen) > 0) {
    outside <- setdiff(patch_ids, chosen)

    # candidates near existing O (local band)
    near <- outside[sapply(outside, function(pid) min(dist_mat[pid, chosen]) <= bleed_dist)]

    if (length(near) > 0) {
      add <- sample(near, size = min(n_bleed, length(near)), replace = FALSE)
      chosen <- unique(c(chosen, add))
    }
  }

  # --- Rebalance to exactly nO without destroying the soft edge:
  # If we have too many O after bleed, drop the most interior ones first
  if (length(chosen) > nO) {
    # interior = far from nearest outside patch
    outside_now <- setdiff(patch_ids, chosen)
    # if outside_now empty, fall back to random trim
    if (length(outside_now) > 0) {
      interior_score <- sapply(chosen, function(pid) min(dist_mat[pid, outside_now]))
      # remove highest interior scores first (deep core), keep edge band
      drop <- chosen[order(interior_score, decreasing = TRUE)][1:(length(chosen) - nO)]
      chosen <- setdiff(chosen, drop)
    } else {
      chosen <- sample(chosen, nO)
    }
  }

  # If we have too few (rare), refill locally if possible
  if (length(chosen) < nO) {
    need <- nO - length(chosen)
    outside <- setdiff(patch_ids, chosen)
    near <- outside[sapply(outside, function(pid) min(dist_mat[pid, chosen]) <= bleed_dist)]
    if (length(near) > 0) {
      add <- sample(near, size = min(need, length(near)), replace = FALSE)
      chosen <- unique(c(chosen, add))
      need <- nO - length(chosen)
    }
    if (need > 0) {
      chosen <- c(chosen, sample(setdiff(patch_ids, chosen), need))
    }
  }

  stopifnot(length(chosen) == nO)
  chosen
}
```

### Big clusters generator

```{r}
#| label: generator-big-clusters

select_orientalis_big_clusters_hard <- function(
  nO, patch_ids, dist_mat, seed = NULL,
  n_centers = 2,
  jitter = 0.10
) {
  if (!is.null(seed)) set.seed(seed)
  if (nO <= 0) return(integer(0))
  if (nO >= length(patch_ids)) return(patch_ids)

  n_centers <- max(1, min(n_centers, nO))
  centers <- sample(patch_ids, n_centers)

  # Allocate cluster sizes that sum to nO
  # Start from equal split, add small random jitter, then renormalize.
  base <- rep(1 / n_centers, n_centers)
  noise <- runif(n_centers, 1 - jitter, 1 + jitter)
  w <- base * noise
  w <- w / sum(w)

  sizes <- pmax(1, as.integer(round(w * nO)))
  # Fix rounding to ensure sum == nO
  diff <- nO - sum(sizes)
  if (diff != 0) {
    # distribute the correction across clusters
    idx <- rep(seq_len(n_centers), length.out = abs(diff))
    if (diff > 0) {
      sizes[idx] <- sizes[idx] + 1
    } else {
      # remove from clusters with size > 1
      for (k in idx) {
        if (sizes[k] > 1) sizes[k] <- sizes[k] - 1
      }
      # if still off due to size==1 constraints, patch later
    }
  }
  # Final correction if still off
  while (sum(sizes) < nO) sizes[which.max(sizes)] <- sizes[which.max(sizes)] + 1
  while (sum(sizes) > nO && any(sizes > 1)) sizes[which.max(sizes)] <- sizes[which.max(sizes)] - 1

  chosen <- integer(0)
  remaining <- patch_ids

  for (k in seq_len(n_centers)) {
    ord <- remaining[order(dist_mat[centers[k], remaining])]
    take <- head(ord, min(sizes[k], length(remaining)))
    chosen <- c(chosen, take)
    remaining <- setdiff(remaining, take)
    if (length(chosen) >= nO) break
  }

  chosen <- unique(chosen)

  # exact nO safety
  if (length(chosen) > nO) chosen <- chosen[1:nO]
  if (length(chosen) < nO) chosen <- c(chosen, sample(setdiff(patch_ids, chosen), nO - length(chosen)))

  stopifnot(length(chosen) == nO)
  chosen
}
```

### Generator wrapper

This function selects which generator to use and passes the parameters from the cluster control panel.

```{r}
#| label: generator-wrapper

select_orientalis <- function(nO, level, patch_ids, dist_mat, seed = NULL) {
  level <- match.arg(level, c("dispersed", "small_clusters", "big_clusters"))

  if (level == "dispersed") {
    spacing_m <- sqrt(length(patch_ids) / max(1, nO)) * GRID_RES
    o <- CLUSTER_OPTS$dispersed

    return(select_orientalis_dispersed_poisson(
      nO, patch_ids, dist_mat,
      base_spacing_m = spacing_m,
      seed = seed,
      strength = o$strength,
      relax_step = o$relax_step,
      max_relax = o$max_relax
    ))
  }

  if (level == "small_clusters") {
    o <- CLUSTER_OPTS$small_clusters
    return(select_orientalis_small_clusters_soft(
      nO, patch_ids, dist_mat,
      seed = seed,
      n_centers = o$n_centers,
      sigma_m = o$sigma_m,
      bleed_rate = o$bleed_rate,
      bleed_dist = o$bleed_dist
    ))
  }

  if (level == "big_clusters") {
    o <- CLUSTER_OPTS$big_clusters
    return(select_orientalis_big_clusters_hard(
      nO, patch_ids, dist_mat,
      seed = seed,
      n_centers = o$n_centers,
      jitter = o$jitter
    ))
  }

  stop("Unknown level")
}
```

------------------------------------------------------------------------

## Main generator: write Nemo-age inputs

```{r}
#| label: generate-inputs

generate_empty_land_inputs <- function(
  prop_levels, cluster_levels, n_reps,
  coords_df, dist_mat,
  out_dirs, planting_scheme,
  seed_base = 20260116
) {
  patch_ids <- coords_df$patchID
  n_patches <- length(patch_ids)

  stage_mat <- build_patch_init_stage_size_empty(n_patches, scheme = planting_scheme)
  manifest <- data.table()

  for (p in prop_levels) {
    nO <- as.integer(round(p * n_patches))

    for (cl in cluster_levels) {
      for (r in seq_len(n_reps)) {

        sim_name <- scenario_id(p, cl, r)

        seed <- seed_base +
          round(p * 1000) * 10000 +
          match(cl, cluster_levels) * 100 +
          r

        O_ids <- select_orientalis(
          nO = nO,
          level = cl,
          patch_ids = patch_ids,
          dist_mat = dist_mat,
          seed = seed
        )

        conf <- build_config_table(O_ids, patch_ids)

        cfg_file <- file.path(out_dirs$cfg, paste0(sim_name, ".txt"))
        write_config_quarto_schema(conf, sim_name, cfg_file)

        q_mat <- build_quanti_init(conf, n_patches)
        q_file <- file.path(out_dirs$quanti, paste0("quanti_init_file_", sim_name, ".txt"))
        write.matrix.nemo(q_mat, q_file)

        s_file <- file.path(out_dirs$stage, paste0("patch_init_stage_size_", sim_name, ".txt"))
        write.matrix.nemo(stage_mat, s_file)

        manifest <- rbind(
          manifest,
          data.table(
            sim_name = sim_name,
            prop_orientalis = p,
            n_orientalis = nO,
            cluster_level = cl,
            replicate = r,
            seed = seed,
            cfg_file = cfg_file,
            quanti_file = q_file,
            stage_file = s_file
          )
        )
      }
    }
  }

  manifest_file <- file.path(OUT_BASE, "manifest_empty_land.tsv")
  fwrite(manifest, manifest_file, sep = "\t")

  manifest
}
```

------------------------------------------------------------------------

## Run generation

```{r}
#| label: run-generation

manifest <- generate_empty_land_inputs(
  prop_levels = PROP_LEVELS,
  cluster_levels = CLUSTER_LEVELS,
  n_reps = N_REPS,
  coords_df = coords,
  dist_mat = dist_mat,
  out_dirs = DIRS,
  planting_scheme = PLANTING_SCHEME,
  seed_base = SEED_BASE
)
```

------------------------------------------------------------------------

## Plot replicate overviews

For each scenario (e.g. 5% + dispersed) we create a single combined plot showing all replicates side-by-side.

```{r}
#| label: replicate-overviews

plot_grid_binary_gg <- function(conf_dt, coords_df, title = NULL) {
  df <- merge(coords_df, conf_dt, by = "patchID", all.x = TRUE)
  df$patch_value <- ifelse(is.na(df$patch_value), "S", df$patch_value)

  ggplot(df, aes(x = x_plot, y = y_plot, fill = patch_value)) +
    geom_tile(color = "grey85", linewidth = 0.1) +
    coord_equal() +
    labs(title = title, x = "", y = "", fill = "") +
    theme_minimal(base_size = 11) +
    theme(
      panel.grid = element_blank(),
      legend.position = "none",
      plot.title = element_text(size = 10, hjust = 0.5)
    )
}

PLOT_REP_DIR <- file.path(DIRS$plots, "replicates")
dir.create(PLOT_REP_DIR, showWarnings = FALSE, recursive = TRUE)

scenario_groups <- manifest %>%
  as.data.frame() %>%
  mutate(scenario_key = sub("_rep[0-9]+$", "", sim_name)) %>%
  group_by(scenario_key, prop_orientalis, cluster_level) %>%
  summarise(cfg_files = list(cfg_file), sims = list(sim_name), .groups = "drop")

for (i in seq_len(nrow(scenario_groups))) {
  sc_key <- scenario_groups$scenario_key[i]
  p <- scenario_groups$prop_orientalis[i]
  cl <- scenario_groups$cluster_level[i]

  cfg_files <- unlist(scenario_groups$cfg_files[i])
  sims <- unlist(scenario_groups$sims[i])

  ord <- order(sims)
  cfg_files <- cfg_files[ord]
  sims <- sims[ord]

  plist <- vector("list", length(cfg_files))
  for (j in seq_along(cfg_files)) {
    cfg <- fread(cfg_files[j])
    rep_lab <- sub("^.*_rep", "rep", sims[j])
    plist[[j]] <- plot_grid_binary_gg(cfg[, .(patchID, patch_value)], coords, title = rep_lab)
  }

  main_title <- sprintf("Empty land | Orientalis %.0f%% | %s", 100 * p, cl)
  panel <- cowplot::plot_grid(plotlist = plist, nrow = 1, align = "hv")

  final <- cowplot::plot_grid(
    cowplot::ggdraw() + cowplot::draw_label(main_title, fontface = "bold", size = 14),
    panel,
    ncol = 1,
    rel_heights = c(0.12, 1)
  )

  out_combined <- file.path(PLOT_REP_DIR, paste0("overview_", sc_key, ".png"))
  ggsave(out_combined, final, width = 16, height = 3.8, dpi = 220)
}
```
